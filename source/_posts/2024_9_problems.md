---
title: 2024 9月杂题记
cover: https://lucky-cloud09.github.io/img/b1.jpg
categories: 杂题
date: 2024/9/6
---

## [[HNOI2010] 城市建设](https://www.luogu.com.cn/problem/P3206)

> 题目大意：给你一张图，边权会有 $q$ 次修改，并保留修改。求每次修改完后的 mst;

这样的大概率是线段树分治。

考虑怎么写，每一条边的边权都会有一个适用的时间，将这条边放入线段树内的对应时间。

我们考虑每次 solve 是怎么做。

我们考虑在当前的 $l,r$ 去做，在时间 $l \sim r$ 的边称为动态边，否则为静态，那么我们考虑将静态边的集合给缩小，并下传。

第一种是无用边，即有边权更小的代替他，舍弃即可。

第二种是必要边，即使用动态边后，依旧需要这条边才能使得图连通，直接加入答案即可。

第三种是其他边，即需传入下一层，将他变成连接两个连通块的边即可。

在每一层，$l \sim r$，若往 $l \sim mid$ 走，那么 $mid + 1 \sim r$ 的动态边转变为静态边。

另一种也差不多。最后到 $[k,k]$ 就是静态的 kruskal。

## [CF715C Digit Tree](https://www.luogu.com.cn/problem/CF715C)

> 题目大意：一棵边权 $1 \le w \le 9$ 的树，给定一个数 $M$。$\gcd(M, 10) = 1$。
> 给一个有序的点对 $(u, v)$，若从左到右记录下 $u$ 到 $v$ 经过的边，若这个数能被 $M$ 整除，则称为特殊的。
> 求有多少个特殊点对。

太套路了。一眼淀粉质。

我们处理一下 $10$ 的幂，和他的逆元。

然后我们用一个桶记录一下 $u-rt$ 的路径，然后我们就可以在 $rt$ 合并路径，计算答案。

## [CF1396C Monster Invaders](https://www.luogu.com.cn/problem/CF1396C)

> 题目大意：略。

考虑通关方案。

1. 当前这一关先给全体怪扣 $1$ 点血，进入下一关，同样的操作，回到上一关。然后给 boss 来一枪。再到下一关来一枪，然后进入第三关。
2. 先杀小怪，然后秒掉 boss 进入下一关。
3. 当前这一关先给全体怪扣 $1$ 点血，进入下一关，但是我们要先杀光小怪，并秒了 boss 回去，打了 boss 进入下一关。

这样就很好写 DP 了。

## [Empty Rectangles](https://www.luogu.com.cn/problem/CF364E)

> 题目大意：你有一个n*m的01矩阵，现在询问在这其中有多少个子矩阵满足包含k个1，即和为k。

很妙的分治。

对于每一次，我们选分治横或列。

对于分治行，我们设当前矩形为 $a,b,c,d$，则 $mid$ 为 $\lfloor \frac{a+c}{2} \rfloor$。

对于 $a\sim mid$，我们设 $up_k$ 表示矩形满足矩形内的和 $\le k$ 最小的上边界。可以发现，他形成了前缀和，若我们要求满足矩形内和为 $k$ 的上边界个数，那么就是 $up_{k}-up_{k-1}$。

同理对于 $mid$ 下的同样求出个 $down$。

最后合并即可。

## [Weighed Tree Radius](https://www.luogu.com.cn/problem/CF1783G)

> 题目大意：给定一棵树，$d_{u,v}$ 表示 $u$ 到 $v$ 经过的边数。点有点权 $a_i$，求 $\min(\max_u(d_{u,v} + a_v))$，我们会有将 $a_u$ 改为 $v$ 的若干次操作。

我们考虑什么东西在树上是所有点中到达最远的距离的最小值，那这就是半径。

那么很容易想到 $r=\lfloor \frac{d}{2} \rfloor$。那么 $d$ 是什么，$d = \max(d_{u,v}+a_v+a_u)$。这就像是在原树每个点挂上两条长度为 $a_u$ 的链。

若 $mid$ 为直径的中点，若它在原树上,答案就是 $\lfloor \frac{d}{2} \rfloor$，否则在 $a_u$ 这样的链上，这样你会发现第二种情况不会存在会替换为 $(u,u)$。

我们需要动态求直径。bfs 求直径的方法，给了我们启示，若有两条备选直径，则直径两个点存在于备选直径的端点。我们就可以用线段树维护了。

## [游客与区间]()

> 题目大意：有多个区间，称划分为好的要满足所有区间分为两个不为空的集合。并且有公共点的在同一个集合。

容易想到，划分一定是以 $x$ 为界，满足 $r\le x$ 的在一个，$l > x$ 的在一个，只需用差分统计跨过 $x$ 的区间数。

## [游客与染色]()

> 题目大意：给 $n\times m$ 的矩阵。将 $0,1$ 填入矩阵，需要每个点有颜色，$2\times 2$ 的矩阵中 $0$ 的数量为偶数。每次操作将 $x,y$ 填为 $c$。保证 $x,y$ 之前没填过。求将未填数的点填后有多少中满足条件的矩阵有几个。

简单题，但我之前没想到。 

这种题都有个套路，确定第一行第一列，即可确定整个合法矩阵。而且证明也很简单。考虑没有约束，答案即为 $2^{n+m-1}$。

约束也很简单，就是 $x$ 行 $1$ 列填啥，那么 $1$ 行 $y$ 列就填啥。

我们用并查集维护即可。

## [[HNOI2016] 网络](https://www.luogu.com.cn/problem/P3250)

看到题目第一眼线段树分治，发现不会，考虑其他做法。

对这种题的敏感度下降了。我们考虑单个询问。

可以二分。$\ge mid$ 的重要的请求，将链加 $1$，用线段树实现。

考虑整体二分即可。

## [[POI2015] ODW](https://www.luogu.com.cn/problem/P3591)

虽然是很一眼的根号分治，但我还是做不出来。

考虑阈值 $B$。

我们考虑求出 $u$ 到根经过的点的权值，注意，可以到不了根。

$> B$ 的我们可以暴力跳。

$\le B$ 我们处理一个数组 $sum_{i, j}$ 表示步伐为 $i$，从深度 $j$ 开始到的了 $u$ 经过的权值之和。

我们考虑使用类似于树上差分的方法进行标记，求出答案。

## [[COCI2018-2019#2] Deblo](https://www.luogu.com.cn/problem/P7310)

> 题目大意：给树。求所有路径经过的点权的异或和的和。

简单 DP 就可以了。

## [[POI2015] PUS](https://www.luogu.com.cn/problem/P3588)

> 题目大意：给你一个长度为 $n$ 的序列 $a$，已知 $a$ 中的 $s$ 个数，给你 $m$ 个限制：给你 $l,r,k$，并给你 $k$ 个下标 $l \le x \le r$。使得 $[l,r]$ 中的这 $k$ 个数严格大于剩下的其他数。

考虑对每个 $k$ 建立超级点 $s$。将他与 $k$ 个数连边。

那么只需要将超级点与除开 $k$ 个数的数连边。发现连的是区间，用 **线段树优化建图** 即可。

判环。然后用拓扑排序即可。

## [[春季测试 2023] 圣诞树](https://www.luogu.com.cn/problem/P9119)

典中典的区间 DP。

设 $f_{i,j,0/1}$，表示当前将 $[i,j]$ 连完，线在左端还是在右端。很明显，每次有连接的都是区间，就可以区间 DP 做了。同时记录下状态，最后就可以输出序列了。

## [天才俱乐部]()

> 题目大意：给定长度为 $n$ 的正整数序列和正整数 $s$，求是否存在 $k$ 使的 $\sum_{i=1}^{n}(a_i \mod k) = s$，$n\le 100,a_i \le 10^9$。

简单题都不能一眼看穿了。

变换一下 $$\sum_{i=1}^{n}(a_i \mod k) = s\\
            \sum_{i=1}^{n}(a_i - \lfloor \frac{a_i}{k} \rfloor \times k) = s\\
            \sum_{i=1}^{n}a_i -s=\lfloor \frac{a_i}{k} \rfloor \times k$$

也就是说，因为他们都是整数，所以 $k|\sum_{i=1}^{n}a_i -s$。因为后面一坨是定值，所以去枚举 $\sum_{i=1}^{n}a_i -s$ 的因数，并验算一下即可。

## [实战教学]()

> 题目大意：给两个长度为 $2n$ 的数组 $a$，$b$。需要将 $1\sim 2n$ 两两配对。$(x,y)$，求出 $\max_{i = 1}^{n}(\max(a_{x_i},a_{y_i}) + \max(b_{x_i},b_{y_i}))$ 的最小值。

第二次看还是不会。

首先，最大值最小容易想到二分。

我们首先将柿子里面的 $\max$ 限制给去掉。所以先将 pair 按照 $a$ 从大到小排序。

二分一个 $lim$。

首先对于 $a_i + b_i > lim$ 肯定不合法，返回 $0$ 即可。

对于每个 $a_i$ 求出 $lim - a_i$。

那么对于 $b_j$ 的要求就是 $b_j \le lim - a_i$。

可以发现我们可以用双指针维护。我们考虑用什么样的 $j$ 与 $i$ 配对最优。贪心的，肯定是 $a_j$ 越大越好。用个 set 维护即可，当然 $j$ 要满足没有配对过。

## [[HAOI2017] 方案数](https://www.luogu.com.cn/problem/P3734)

> 题目大意：三元组 $(x, y, z)$ 可以移动到另一个三元组，当且仅当新的三元组只有一个数与上之前的为之前的，且其他的相同。如 $(x,y,z)$ 可以到 $(x',y,z)$ 仅当 $x \bigwedge x' = x$。以此类推。
> 我们要到 $(n,m,r)$，其中有一些关键点不能走过。求方案数。

感觉我自我设限太严重了，这题感觉其实可以独立切的。

考虑没有关键点。

首先有一个结论 $(x,y,z)$ 到 $(x',y',z')$ 那么 $x' \ge x，y' \ge y，z'\ge z$。

我们把他放到二进制下。发现每次都是有 $x, y, z$ 其中一个数的**某些** $0$ 变为 $1$。

我们叫 count($x$) 为 $x$ 在二进制下一的个数。

可以 DP。设 $f_{i,j,k}$ 表示当前到了 count($x$) $= i$，count($y$) $= j$，count($z$) $= k$ 的点。

枚举增加哪一个数，并且将多少为变为一。

以 $x$ 增加 $l$ 为例。

$$f_{i,j,k} = f_{i,j,k} + \binom{i}{l} \times f_{i-l,j,k}$$

其他的类似。

但是有关键点。

考虑将关键点按三个关键字排序。并且 $(n,m,r)$ 作为关键点。

对于当前 $i$ 关键点 $(x,y,z)$，因为排序所以可以转移到 $(x,y,z)$ 的点都处理过了。

设 $dp_i$ 表示不经过其他关键点的方案数。

将 $dp_i$ 赋值为 $f_{count(x),count(y),count(z)}$。

找到所有可以到 $i$ 的 $j$，$dp_i = dp_i - dp_j \times f_{count(x) - count(x'),count(y) - count(y'),count(z) - count(y')}$。

最后输出答案即可。

## [Cake Division](https://www.luogu.com.cn/problem/AT_abc370_f)

> 题目大意：给出一个长度为 $N$ 的环，要求分成 $K$ 段，设第 $i$ 段的总和为 $S_i$，则求出 $\min(S_1, S_2 ... S_{N-1}, S_N)$。

太菜了。真的不会。

但是，二分很容易想到。我们发现他是一个环，这就需要我们去枚举起点。正常做 $O(nk\log V)$。如何优化跳点的过程。我们可以用倍增维护。

还有一个子问题，分割线有多少是一定用的。

我们可以证明若一个点作为起点不可以分 $K$ 个，则一定不可以。

## [[NOI Online 2021 提高组] 岛屿探险](https://www.luogu.com.cn/problem/P7470)

大型分讨加可持久化 Trie。后面有空补。

## 莓良心

> 题目大意：有一个长度为 $n$ 的序列 $a$。我们将其分成 $k$ 组，每组贡献为组内数的数量与组内数的和之乘。求所有分组方案的贡献 $\mod 998244353$，其中每个组都要有数。

我们考虑每个数的贡献。然后，你会发现，他没有什么前途。那么我们考虑怎么去搞出数量这个限制。

你会发现，我们将一个数放在一组，他可以与组内每个数（包括本身）给出贡献 $a_u$。

你会发现，每个二元组 $(x,y)$ 都会给他们存在同一组的方案贡献 $a_x + a_y$。

那么你就可以推出

$$ans = (\sum a_i) \times \begin{Bmatrix} n \\ k \end{Bmatrix} + \sum_{u \ne v} (a_u + a_v) \times \begin{Bmatrix} n - 1 \\ k \end{Bmatrix}$$

$$ans = (\sum a_i) \times (\begin{Bmatrix} n \\ k \end{Bmatrix} + (n-1) \times \begin{Bmatrix} n - 1 \\ k \end{Bmatrix})$$

$\{ \}$ 表示第二类斯特林数。

## 尽梨了

> 题目大意：$n$ 个商店。从一个商店到另一个商店或开始时均要花 $1$ 时间。在一个商店买东西，花 $a_i \times t + b_i$ 时间。$t$ 是之前花的时间。问 $T$ 时间最多买多少个。

我们先考虑贪心。

我们先进 $i$ 商店，后进 $j$ 商店，与先进 $j$ 的花费时间进行对比。

可以列出不等式。

$$(t\times a_i + b_i + 1 + t) \times a_j + b_j + t + 1+t\times a_i + b_i < (t\times a_j + b_j + 1 + t) \times a_i + b_i + t + 1+t\times a_j + b_j$$

$$(a_i+1) \times a_j < (a_j +1) \times a_i$$

那么我们考虑 DP。

我们要花费最少的时间，就一定是排完序的子序列。设 $dp_{i,j}$ 表示前 $i$ 个商店去 $j$ 个花的最少时间。

然后因为对于 $a_i > 0$ 的情况，至多去 $\log T$ 个，所以就可以 $n \log T$ DP。

对于 $a_i = 0$，他一定在序列末尾，利用双指针就可以做了。

