---
title: 2024 9月杂题记
cover: https://lucky-cloud09.github.io/img/b1.jpg
categories: 题解
date: 2024/9/6
---

## [[HNOI2010] 城市建设](https://www.luogu.com.cn/problem/P3206)

> 题目大意：给你一张图，边权会有 $q$ 次修改，并保留修改。求每次修改完后的 mst;

这样的大概率是线段树分治。

考虑怎么写，每一条边的边权都会有一个适用的时间，将这条边放入线段树内的对应时间。

我们考虑每次 solve 是怎么做。

我们考虑在当前的 $l,r$ 去做，在时间 $l \sim r$ 的边称为动态边，否则为静态，那么我们考虑将静态边的集合给缩小，并下传。

第一种是无用边，即有边权更小的代替他，舍弃即可。

第二种是必要边，即使用动态边后，依旧需要这条边才能使得图连通，直接加入答案即可。

第三种是其他边，即需传入下一层，将他变成连接两个连通块的边即可。

在每一层，$l \sim r$，若往 $l \sim mid$ 走，那么 $mid + 1 \sim r$ 的动态边转变为静态边。

另一种也差不多。最后到 $[k,k]$ 就是静态的 kruskal。

## [CF715C Digit Tree](https://www.luogu.com.cn/problem/CF715C)

> 题目大意：一棵边权 $1 \le w \le 9$ 的树，给定一个数 $M$。$\gcd(M, 10) = 1$。
> 给一个有序的点对 $(u, v)$，若从左到右记录下 $u$ 到 $v$ 经过的边，若这个数能被 $M$ 整除，则称为特殊的。
> 求有多少个特殊点对。

太套路了。一眼淀粉质。

我们处理一下 $10$ 的幂，和他的逆元。

然后我们用一个桶记录一下 $u-rt$ 的路径，然后我们就可以在 $rt$ 合并路径，计算答案。

## [CF1396C Monster Invaders](https://www.luogu.com.cn/problem/CF1396C)

> 题目大意：略。

考虑通关方案。

1. 当前这一关先给全体怪扣 $1$ 点血，进入下一关，同样的操作，回到上一关。然后给 boss 来一枪。再到下一关来一枪，然后进入第三关。
2. 先杀小怪，然后秒掉 boss 进入下一关。
3. 当前这一关先给全体怪扣 $1$ 点血，进入下一关，但是我们要先杀光小怪，并秒了 boss 回去，打了 boss 进入下一关。

这样就很好写 DP 了。

## [Empty Rectangles](https://www.luogu.com.cn/problem/CF364E)

> 题目大意：你有一个n*m的01矩阵，现在询问在这其中有多少个子矩阵满足包含k个1，即和为k。

很妙的分治。

对于每一次，我们选分治横或列。

对于分治行，我们设当前矩形为 $a,b,c,d$，则 $mid$ 为 $\lfloor \frac{a+c}{2} \rfloor$。

对于 $a\sim mid$，我们设 $up_k$ 表示矩形满足矩形内的和 $\le k$ 最小的上边界。可以发现，他形成了前缀和，若我们要求满足矩形内和为 $k$ 的上边界个数，那么就是 $up_{k}-up_{k-1}$。

同理对于 $mid$ 下的同样求出个 $down$。

最后合并即可。

## [Weighed Tree Radius](https://www.luogu.com.cn/problem/CF1783G)

> 题目大意：给定一棵树，$d_{u,v}$ 表示 $u$ 到 $v$ 经过的边数。点有点权 $a_i$，求 $\min(\max_u(d_{u,v} + a_v))$，我们会有将 $a_u$ 改为 $v$ 的若干次操作。

我们考虑什么东西在树上是所有点中到达最远的距离的最小值，那这就是半径。

那么很容易想到 $r=\lfloor \frac{d}{2} \rfloor$。那么 $d$ 是什么，$d = \max(d_{u,v}+a_v+a_u)$。这就像是在原树每个点挂上两条长度为 $a_u$ 的链。

若 $mid$ 为直径的中点，若它在原树上,答案就是 $\lfloor \frac{d}{2} \rfloor$，否则在 $a_u$ 这样的链上，这样你会发现第二种情况不会存在会替换为 $(u,u)$。

我们需要动态求直径。bfs 求直径的方法，给了我们启示，若有两条备选直径，则直径两个点存在于备选直径的端点。我们就可以用线段树维护了。

## [游客与区间]()

> 题目大意：有多个区间，称划分为好的要满足所有区间分为两个不为空的集合。并且有公共点的在同一个集合。

容易想到，划分一定是以 $x$ 为界，满足 $r\le x$ 的在一个，$l > x$ 的在一个，只需用差分统计跨过 $x$ 的区间数。

## [游客与染色]()

> 题目大意：给 $n\times m$ 的矩阵。将 $0,1$ 填入矩阵，需要每个点有颜色，$2\times 2$ 的矩阵中 $0$ 的数量为偶数。每次操作将 $x,y$ 填为 $c$。保证 $x,y$ 之前没填过。求将未填数的点填后有多少中满足条件的矩阵有几个。

简单题，但我之前没想到。 

这种题都有个套路，确定第一行第一列，即可确定整个合法矩阵。而且证明也很简单。考虑没有约束，答案即为 $2^{n+m-1}$。

约束也很简单，就是 $x$ 行 $1$ 列填啥，那么 $1$ 行 $y$ 列就填啥。

我们用并查集维护即可。

## [[HNOI2016] 网络](https://www.luogu.com.cn/problem/P3250)

看到题目第一眼线段树分治，发现不会，考虑其他做法。

对这种题的敏感度下降了。我们考虑单个询问。

可以二分。$\ge mid$ 的重要的请求，将链加 $1$，用线段树实现。

考虑整体二分即可。

## [[POI2015] ODW](https://www.luogu.com.cn/problem/P3591)

虽然是很一眼的根号分治，但我还是做不出来。

考虑阈值 $B$。

我们考虑求出 $u$ 到根经过的点的权值，注意，可以到不了根。

$> B$ 的我们可以暴力跳。

$\le B$ 我们处理一个数组 $sum_{i, j}$ 表示步伐为 $i$，从深度 $j$ 开始到的了 $u$ 经过的权值之和。

我们考虑使用类似于树上差分的方法进行标记，求出答案。

## [[COCI2018-2019#2] Deblo](https://www.luogu.com.cn/problem/P7310)

> 题目大意：给树。求所有路径经过的点权的异或和的和。

简单 DP 就可以了。

## [[POI2015] PUS](https://www.luogu.com.cn/problem/P3588)

> 题目大意：给你一个长度为 $n$ 的序列 $a$，已知 $a$ 中的 $s$ 个数，给你 $m$ 个限制：给你 $l,r,k$，并给你 $k$ 个下标 $l \le x \le r$。使得 $[l,r]$ 中的这 $k$ 个数严格大于剩下的其他数。

考虑对每个 $k$ 建立超级点 $s$。将他与 $k$ 个数连边。

那么只需要将超级点与除开 $k$ 个数的数连边。发现连的是区间，用 **线段树优化建图** 即可。

判环。然后用拓扑排序即可。

## [[春季测试 2023] 圣诞树](https://www.luogu.com.cn/problem/P9119)

典中典的区间 DP。

设 $f_{i,j,0/1}$，表示当前将 $[i,j]$ 连完，线在左端还是在右端。很明显，每次有连接的都是区间，就可以区间 DP 做了。同时记录下状态，最后就可以输出序列了。

## [天才俱乐部]()

> 题目大意：给定长度为 $n$ 的正整数序列和正整数 $s$，求是否存在 $k$ 使的 $\sum_{i=1}^{n}(a_i \mod k) = s$，$n\le 100,a_i \le 10^9$。

简单题都不能一眼看穿了。

变换一下 $$\sum_{i=1}^{n}(a_i \mod k) = s\\
            \sum_{i=1}^{n}(a_i - \lfloor \frac{a_i}{k} \rfloor \times k) = s\\
            \sum_{i=1}^{n}a_i -s=\lfloor \frac{a_i}{k} \rfloor \times k$$

也就是说，因为他们都是整数，所以 $k|\sum_{i=1}^{n}a_i -s$。因为后面一坨是定值，所以去枚举 $\sum_{i=1}^{n}a_i -s$ 的因数，并验算一下即可。

## [实战教学]()

> 题目大意：给两个长度为 $2n$ 的数组 $a$，$b$。需要将 $1\sim 2n$ 两两配对。$(x,y)$，求出 $\max_{i = 1}^{n}(\max(a_{x_i},a_{y_i}) + \max(b_{x_i},b_{y_i}))$ 的最小值。

第二次看还是不会。

首先，最大值最小容易想到二分。

我们首先将柿子里面的 $\max$ 限制给去掉。所以先将 pair 按照 $a$ 从大到小排序。

二分一个 $lim$。

首先对于 $a_i + b_i > lim$ 肯定不合法，返回 $0$ 即可。

对于每个 $a_i$ 求出 $lim - a_i$。

那么对于 $b_j$ 的要求就是 $b_j \le lim - a_i$。

可以发现我们可以用双指针维护。我们考虑用什么样的 $j$ 与 $i$ 配对最优。贪心的，肯定是 $a_j$ 越大越好。用个 set 维护即可，当然 $j$ 要满足没有配对过。